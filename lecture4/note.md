## page tables(virtual memory)
虚拟内存
- 一个表将虚拟地址映射到物理地址
- 通过偏移来保存
- 44位虚拟地址映射到64位操作系统
- 每个进程可以有独立的地址空间
- 映射是以块为单位的
- 隔离的基础
- 某种形式的映射


isolation
memory isolation
- 我们希望在不同程序之间真正隔离这些内存

#### Q
- 虚拟地址和物理地址的空间大小问题
  - 物理内存可能耗尽吗---是的
  - syscall lab————kalloc
- 每个stap寄存器的值是由内存保存的  写入satp寄存器是一个特权指令，用户不能更新页面映射寄存器
- 多进程可能会耗尽虚拟内存而没有耗尽物理内存
- 这个物理地址的56，可以理解为可能的内存位置的数目  不是位bit
- 每个进程有自己的映射  这个映射有2^27个条目
- 每个页表的ppn44位+offset12
- 三个页表  如何组成最后的物理地址
  - 1 ppn
- 为什么页面目录保存的是物理页面编号而不是虚拟地址
  - 因为我们要查找内存  比如在内存中查找下一个目录
  - 我们不能使用一种转换方案依赖另一种转换方案
  - satp也是物理，需要知道页面目录的物理页面编号

#### address spaces
- 我们给每个程序包括内核分配自己的内存空间
- pagetables 页表(硬件实现)
  - CPU执行任何与地址有关的命令  地址都是虚拟地址
  - 内存管理单元
  - MMU———地址映射表
  - 给每个应用程序自己的映射
  - 当cpu、os从一个应用程序切换到另一个应用程序，它会切换satp寄存器的内容
- 理论上risc-v有2^64地址  64位处理器  用了39位 大概512G虚拟地址空间
  - 一页4kb， 4096字节  几乎所有处理器  连续的4096字节在内存中  
  - 虚拟地址
    - 索引
    - 偏移量
      - 偏移量+基础页面得到物理地址位置
  - 虚拟地址中27位索引
  - 虚拟地址中12位偏移是因为2^12 = 1096
  - risc-v物理内存2^56  比单个虚拟内存大
- 三级  每级9位  三级512叉树  多级树
- TLB
- satp寄存器存储的是对应进程的page table的物理地址
- 当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节中的某一个，假设offset是12，那么page中的第12个字节被使用了。

#### paging hardware(RISC_V)

#### XV6 vm code + layout

